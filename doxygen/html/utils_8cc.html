<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>WinWipe: utils.cc File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">WinWipe
   </div>
   <div id="projectbrief">Windows File, Folder, Registry, Service and Process Wiper</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">utils.cc File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="build_8h_source.html">build.h</a>&quot;</code><br/>
<code>#include &lt;cstdio&gt;</code><br/>
<code>#include &lt;cstring&gt;</code><br/>
<code>#include &lt;ctype.h&gt;</code><br/>
<code>#include &lt;cassert&gt;</code><br/>
<code>#include &lt;cstdlib&gt;</code><br/>
<code>#include &lt;exception&gt;</code><br/>
<code>#include &quot;<a class="el" href="utils_8h_source.html">utils.h</a>&quot;</code><br/>
<code>#include &lt;Windows.h&gt;</code><br/>
<code>#include &lt;Psapi.h&gt;</code><br/>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af447d208726a022a2c413ca6ae5dc189"><td class="memItemLeft" align="right" valign="top">unsigned __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#af447d208726a022a2c413ca6ae5dc189">divide_by_zero</a> (void *null)</td></tr>
<tr class="separator:af447d208726a022a2c413ca6ae5dc189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a138b647135011ac5c1be76ca1ee502b3"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#a138b647135011ac5c1be76ca1ee502b3">error_code_as_string</a> (<a class="el" href="stdint_8h.html#aaa5d1cd013383c889537491c3cfd9aad">uint64_t</a> code)</td></tr>
<tr class="separator:a138b647135011ac5c1be76ca1ee502b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19072a21aa14204c101b56310a053f00"><td class="memItemLeft" align="right" valign="top">unsigned __stdcall&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#a19072a21aa14204c101b56310a053f00">exit_process</a> (void *null)</td></tr>
<tr class="separator:a19072a21aa14204c101b56310a053f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeed751e935810eb5bfdbcffbb9013c13"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#aeed751e935810eb5bfdbcffbb9013c13">get_current_binary_path</a> (char *buffer, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> buffer_size)</td></tr>
<tr class="separator:aeed751e935810eb5bfdbcffbb9013c13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb234253fc6ab388ccb09dd11b577ec5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#afb234253fc6ab388ccb09dd11b577ec5">get_file_version_info</a> (wchar_t *path, <a class="el" href="structfile__version__info.html">file_version_info</a> *fvi)</td></tr>
<tr class="separator:afb234253fc6ab388ccb09dd11b577ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74f3dd1eda7408b43f7f7fb41465833c"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#a74f3dd1eda7408b43f7f7fb41465833c">get_function_address</a> (char *func_name, wchar_t *module_name)</td></tr>
<tr class="separator:a74f3dd1eda7408b43f7f7fb41465833c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe432f244cf72a14501d60454fdf4ebf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="struct_module_information.html">ModuleInformation</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#afe432f244cf72a14501d60454fdf4ebf">get_loaded_modules</a> ()</td></tr>
<tr class="separator:afe432f244cf72a14501d60454fdf4ebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42ad066921539506df198aebf42ff28d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#aaa5d1cd013383c889537491c3cfd9aad">uint64_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#a42ad066921539506df198aebf42ff28d">get_ms_time</a> ()</td></tr>
<tr class="separator:a42ad066921539506df198aebf42ff28d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdc599d3bbb0d0cbd517c7747a69ab7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#a5cdc599d3bbb0d0cbd517c7747a69ab7">MbToUTF8</a> (wchar_t *buf, const char *mb, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> buf_size)</td></tr>
<tr class="separator:a5cdc599d3bbb0d0cbd517c7747a69ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d99db62cbee3295fa98c3489ac9471"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#a73d99db62cbee3295fa98c3489ac9471">UTF8ToMb</a> (char *buf, const wchar_t *wchar, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> buf_size)</td></tr>
<tr class="separator:a73d99db62cbee3295fa98c3489ac9471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f4e916381d9c267c7c8d8997ed48dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#af1f4e916381d9c267c7c8d8997ed48dd">process_exists</a> (unsigned long pid)</td></tr>
<tr class="separator:af1f4e916381d9c267c7c8d8997ed48dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca003914e08d83abdda7e88d58e50fe"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#afca003914e08d83abdda7e88d58e50fe">skip_whitespace</a> (char *str)</td></tr>
<tr class="separator:afca003914e08d83abdda7e88d58e50fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ff8cc269a34ae7e565ed7663dc2eb3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#a2ff8cc269a34ae7e565ed7663dc2eb3a">strlcat</a> (char *dest, const char *src, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> size)</td></tr>
<tr class="separator:a2ff8cc269a34ae7e565ed7663dc2eb3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63a72ee56ddf07d1f097f4425c1cb38b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#a63a72ee56ddf07d1f097f4425c1cb38b">strlcpy</a> (char *dest, const char *src, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> size)</td></tr>
<tr class="separator:a63a72ee56ddf07d1f097f4425c1cb38b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3028decc6adec38215582336b1584387"><td class="memItemLeft" align="right" valign="top"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#a3028decc6adec38215582336b1584387">str_format</a> (char *destination, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> dest_size, char *format,...)</td></tr>
<tr class="separator:a3028decc6adec38215582336b1584387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae417a5be0043adcf2646caebfab69a"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#aaae417a5be0043adcf2646caebfab69a">str_token</a> (char *src, const char *delim, char **context)</td></tr>
<tr class="separator:aaae417a5be0043adcf2646caebfab69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae449a29602e667a885747f7f1f06c8dd"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#ae449a29602e667a885747f7f1f06c8dd">str_trim</a> (char *src)</td></tr>
<tr class="separator:ae449a29602e667a885747f7f1f06c8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb56a00005481d819a7e43b724b1d748"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="utils_8cc.html#adb56a00005481d819a7e43b724b1d748">time_diff_as_string</a> (time_t start_time, time_t end_time, char *dest, <a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> dest_size)</td></tr>
<tr class="separator:adb56a00005481d819a7e43b724b1d748"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><dl class="section author"><dt>Author</dt><dd>James Warren </dd></dl>
<dl class="section copyright"><dt>Copyright</dt><dd>James Warren, 2013-2014 </dd></dl>
<dl class="section user"><dt>License:</dt><dd>Zlib (see license.txt or <a href="http://opensource.org/licenses/Zlib">http://opensource.org/licenses/Zlib</a>) </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af447d208726a022a2c413ca6ae5dc189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned __stdcall divide_by_zero </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>null</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Triggers a divide by zero exception - used for forcing another process to be killed.</p>
<p>Executed as part of a created thread, which is why it needs a void * as a parameter, and returns unsigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">null</td><td>A placeholder (just pass in nullptr) - not touched by the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0, even if it never gets reached </dd></dl>

</div>
</div>
<a class="anchor" id="a138b647135011ac5c1be76ca1ee502b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* error_code_as_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#aaa5d1cd013383c889537491c3cfd9aad">uint64_t</a>&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a Windows error code to its string counterpart, as processed by the system.</p>
<p>The pointer returned must not be freed - the function maintains a static buffer, and the pointer is looking at it when it is returned. This limits an error message to 511 characters, which should be enough for anything.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>The Win32 error code (sometimes a long, sometimes unsigned long, but all should be good for the system). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the start of the error string, or a nullptr if the FormatMessage() function failed. </dd></dl>

</div>
</div>
<a class="anchor" id="a19072a21aa14204c101b56310a053f00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned __stdcall exit_process </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>null</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calls ExitProcess() - used for forcing another process to be killed.</p>
<p>Executed as part of a created thread, which is why it needs a void * as a parameter, and returns unsigned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">null</td><td>A placeholder (just pass in nullptr) - not touched by the function </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns 0, even if it never gets reached </dd></dl>

</div>
</div>
<a class="anchor" id="aeed751e935810eb5bfdbcffbb9013c13"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> get_current_binary_path </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>buffer_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieves the current path for the executing binary, storing the result in the supplied <em>buffer</em>. Comes with the trailing [back]slash.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buffer</td><td>The preallocated buffer to store the result in </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer_size</td><td>The size of the preallocated buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the amount of characters written to buffer if successful </dd>
<dd>
On failure, 0 is returned </dd></dl>

</div>
</div>
<a class="anchor" id="afb234253fc6ab388ccb09dd11b577ec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool get_file_version_info </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structfile__version__info.html">file_version_info</a> *&#160;</td>
          <td class="paramname"><em>fvi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the version information for the specified file.</p>
<p>A <a class="el" href="structfile__version__info.html">file_version_info</a> struct is passed in, which will contain the results of the data acquisition. It is immediately reset to 0 or blank values, in the event of failure. ntdll on Win7 SP1 x64 would be:</p>
<ul>
<li>major = 6</li>
<li>minor = 1</li>
<li>rev = 7601</li>
<li>build = 18229</li>
</ul>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">true</td><td>if the acquisition succeeds, and the struct populated </td></tr>
    <tr><td class="paramname">false</td><td>if the acquisition fails </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>get file description </dd></dl>

</div>
</div>
<a class="anchor" id="a74f3dd1eda7408b43f7f7fb41465833c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* get_function_address </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>func_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>module_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtains the memory address of func_name, which resides in the module_name library. Essentially a wrapper around GetProcAddress(), which loads the module for you.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">func_name</td><td>The name of the function to get </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">module_name</td><td>The name of the module to search within for func_name </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">nullptr</td><td>on failure, as a result of an invalid parameter, or if the function was not found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>On success, a pointer to the requested functions memory address is returned. </dd></dl>

</div>
</div>
<a class="anchor" id="afe432f244cf72a14501d60454fdf4ebf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="struct_module_information.html">ModuleInformation</a>*&gt; get_loaded_modules </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enumerates all the loaded modules in the running process, and logs them to file. Does not check if the config has logging enabled; the caller should do so.</p>
<dl class="section warning"><dt>Warning</dt><dd>Each ModuleInformation* returned needs its memory freeing when it is no longer needed; failure to do so will result in a memory leak.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of structs containing information, such as the name and address, of each loaded module. </dd></dl>

</div>
</div>
<a class="anchor" id="a42ad066921539506df198aebf42ff28d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#aaa5d1cd013383c889537491c3cfd9aad">uint64_t</a> get_ms_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the current time in milliseconds.</p>
<p>Used for timing operations - store the first call to this as a start_time, and then use the second call to determine the duration.</p>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of milliseconds since January 1, 1601 (UTC). </dd></dl>

</div>
</div>
<a class="anchor" id="a5cdc599d3bbb0d0cbd517c7747a69ab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MbToUTF8 </td>
          <td>(</td>
          <td class="paramtype">wchar_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>mb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take heed of the security implications; see: <a href="http://msdn.microsoft.com/en-us/library/dd319072(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/dd319072(v=vs.85).aspx</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mb</td><td>The multi-byte string to convert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_size</td><td>The size of the buffer pointed to by buf, in characters </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if the pointers are null, buf_size is not at least 2, or if MultiByteToWideChar() fails </td></tr>
    <tr><td class="paramname">true</td><td>if the conversion succeeds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af1f4e916381d9c267c7c8d8997ed48dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool process_exists </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>pid</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afca003914e08d83abdda7e88d58e50fe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* skip_whitespace </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>str</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Skips over all preceeding whitespace present in <em>str</em>.</p>
<p>Has Test Case: no</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The source string to skip over </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the incremented source string </dd></dl>

</div>
</div>
<a class="anchor" id="a3028decc6adec38215582336b1584387"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> str_format </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>dest_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Formats a string into the buffer specified by <em>dest</em>.</p>
<p>This function is identical to snprintf, only there is no need to concern with the buffer size. Nul-termination is guaranteed if <em>dest_size</em> is at least 1. Improper use of format strings can still result in security risks, so always use as much safety as you would to normal statements.</p>
<p>char buf[24]; int32_t num = 5; str_format("The integer is: %i; amazing stuff!\\n", num);</p>
<p>In this case, the string is truncated to "The integer is: 5; amaz".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">destination</td><td>The destination buffer </td></tr>
    <tr><td class="paramname">dest_size</td><td>The size of the destination buffer </td></tr>
    <tr><td class="paramname">format</td><td>The format of the string to generate, printf-style </td></tr>
    <tr><td class="paramname">...</td><td>va_args as determined by the format string. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the number of characters written to <em>destination</em>, excluding the nul. If the buffer is not large enough, and truncation has occurred, the return value is 0 - but <em>destination</em> is populated with as much as it can. </dd></dl>

</div>
</div>
<a class="anchor" id="aaae417a5be0043adcf2646caebfab69a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* str_token </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>delim</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>last</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A reentrant version of strtok; return values and functionality is identical to that of strtok_r (as it does not exist on Windows). The <em>input</em> will be modified, so store a copy if you wish to retain any existing data it holds.</p>
<p>Has Test Case: yes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">input</td><td>The input string to parse; should be NULL after the initial call until all tokens are obtained </td></tr>
    <tr><td class="paramname">delim</td><td>The set of characters that delimit the tokens in input; i.e. "\\r\\n" will tokenize every instance of '\r', then '\n', etc. </td></tr>
    <tr><td class="paramname">last</td><td>Maintains context - must point to a nullptr in the first call </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a pointer to the next token, or nullptr if there are no more. </dd></dl>

</div>
</div>
<a class="anchor" id="ae449a29602e667a885747f7f1f06c8dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* str_trim </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes any trailing and preceeding whitespace from <em>src</em>. A nul terminator is inserted at the final whitespace character when working in reverse.</p>
<p>" This string has a tab and space at the end\t " will be trimmed down to: "This string has a tab and space at the end"</p>
<p>Has Test Case: no</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The string to be trimmed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns src at a non-leading whitespace offset </dd></dl>

</div>
</div>
<a class="anchor" id="a2ff8cc269a34ae7e565ed7663dc2eb3a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> strlcat </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A duplicate of OpenBSD's strlcat.</p>
<p>Appends <em>src</em> into the buffer specified by <em>dest</em>, up to a limit of <em>size</em> </p>
<ul>
<li>1. Nul termination is guaranteed if <em>size</em> is at least 1.</li>
</ul>
<p>Unlike the OpenBSD version of strlcat, if no nul is found in <em>dest</em>, it is inserted at the final position. This is a change for tiny safety sake.</p>
<p>Has Test Case: yes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer </td></tr>
    <tr><td class="paramname">src</td><td>The string to append </td></tr>
    <tr><td class="paramname">size</td><td>The size of the destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string that was attempted to be created. So, strlen of <em>dest</em> + strlen of <em>src</em>. If this is greater than or equal to <em>size</em>, truncation has occurred, and should be handled by the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="a63a72ee56ddf07d1f097f4425c1cb38b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> strlcpy </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A duplicate of OpenBSD's strlcpy.</p>
<p>Copies <em>src</em> into the buffer specified by <em>dest</em>, up to a limit of <em>size</em> </p>
<ul>
<li>1. Always starts copying <em>src</em> and overwrites anything previously there. nul termination is guaranteed if <em>size</em> is at least 1.</li>
</ul>
<p>Has Test Case: yes</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>The destination buffer </td></tr>
    <tr><td class="paramname">src</td><td>The string to copy </td></tr>
    <tr><td class="paramname">size</td><td>The size of the destination buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The length of the string that was attempted to be created. So, strlen of <em>src</em>. If this is greater than or equal to <em>size</em>, truncation has occurred, and should be handled by the caller. </dd></dl>

</div>
</div>
<a class="anchor" id="adb56a00005481d819a7e43b724b1d748"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool time_diff_as_string </td>
          <td>(</td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>start_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">time_t&#160;</td>
          <td class="paramname"><em>end_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>dest_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a73d99db62cbee3295fa98c3489ac9471"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool UTF8ToMb </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const wchar_t *&#160;</td>
          <td class="paramname"><em>wchar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="stdint_8h.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a>&#160;</td>
          <td class="paramname"><em>buf_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take heed of the security implications; see: <a href="http://msdn.microsoft.com/en-us/library/dd374130(v=vs.85).aspx">http://msdn.microsoft.com/en-us/library/dd374130(v=vs.85).aspx</a></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">buf</td><td>The destination buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">wchar</td><td>The wide-character string to convert </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf_size</td><td>The size of the buffer pointed to by buf </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">false</td><td>if the pointers are null, buf_size is not at least 2, or if MultiByteToWideChar() fails </td></tr>
    <tr><td class="paramname">true</td><td>if the conversion succeeds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Apr 9 2014 00:47:24 for WinWipe by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
